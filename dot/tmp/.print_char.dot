digraph "CFG for 'print_char' function" {
	label="CFG for 'print_char' function";

	Node0x5565e7bb0630 [shape=record,color="#3d50c3ff", style=filled, fillcolor="#b9d0f970",label="{entry:\l  %stktop_8 = alloca i8, i32 24, align 1\l  %tos = ptrtoint ptr %stktop_8 to i64\l  %0 = add i64 %tos, 16\l  %RBP_N.8 = inttoptr i64 %0 to ptr\l  %1 = add i64 %tos, 0\l  %RSP_P.0 = inttoptr i64 %1 to ptr\l  store i64 3735928559, ptr %RSP_P.0, align 8\l  %RBP = ptrtoint ptr %RSP_P.0 to i64\l  store i64 %arg1, ptr %RBP_N.8, align 1\l  %2 = ptrtoint ptr %stktop_8 to i64\l  %3 = add i64 %2, 4\l  %4 = inttoptr i64 %3 to ptr\l  store i32 0, ptr %4, align 1\l  br label %bb.1\l}"];
	Node0x5565e7bb0630 -> Node0x5565e7bb0ea0;
	Node0x5565e7bb0ea0 [shape=record,color="#b70d28ff", style=filled, fillcolor="#b70d2870",label="{bb.1:                                             \l  %5 = ptrtoint ptr %stktop_8 to i64\l  %6 = add i64 %5, 4\l  %7 = inttoptr i64 %6 to ptr\l  %memload = load i64, ptr %7, align 1\l  %8 = trunc i64 %memload to i32\l  %RAX = sext i32 %8 to i64\l  %9 = sub i64 %RAX, 8\l  %10 = call \{ i64, i1 \} @llvm.usub.with.overflow.i64(i64 %RAX, i64 8)\l  %CF = extractvalue \{ i64, i1 \} %10, 1\l  %ZF = icmp eq i64 %9, 0\l  %highbit = and i64 -9223372036854775808, %9\l  %SF = icmp ne i64 %highbit, 0\l  %11 = call \{ i64, i1 \} @llvm.ssub.with.overflow.i64(i64 %RAX, i64 8)\l  %OF = extractvalue \{ i64, i1 \} %11, 1\l  %12 = and i64 %9, 255\l  %13 = call i64 @llvm.ctpop.i64(i64 %12)\l  %14 = and i64 %13, 1\l  %PF = icmp eq i64 %14, 0\l  %CFCmp_JAE = icmp eq i1 %CF, false\l  br i1 %CFCmp_JAE, label %bb.3, label %bb.2\l|{<s0>T|<s1>F}}"];
	Node0x5565e7bb0ea0:s0 -> Node0x5565e7bb1e10;
	Node0x5565e7bb0ea0:s1 -> Node0x5565e7bb1e80;
	Node0x5565e7bb1e80 [shape=record,color="#b70d28ff", style=filled, fillcolor="#bb1b2c70",label="{bb.2:                                             \l  %15 = ptrtoint ptr %stktop_8 to i64\l  %16 = add i64 %15, 4\l  %17 = inttoptr i64 %16 to ptr\l  %memload1 = load i32, ptr %17, align 1\l  %EAX = call i32 (ptr, ...) @printf(ptr getelementptr inbounds ([112 x i8],\l... ptr @rodata_15, i32 0, i32 16), i32 %memload1)\l  %memload2 = load i64, ptr %RBP_N.8, align 1\l  %18 = ptrtoint ptr %stktop_8 to i64\l  %19 = add i64 %18, 4\l  %20 = inttoptr i64 %19 to ptr\l  %memload3 = load i64, ptr %20, align 1\l  %21 = trunc i64 %memload3 to i32\l  %RDX = sext i32 %21 to i64\l  %memref-basereg = add i64 %memload2, %RDX\l  %22 = inttoptr i64 %memref-basereg to ptr\l  %memload4 = load i32, ptr %22, align 1\l  %23 = trunc i32 %memload4 to i8\l  %ESI = sext i8 %23 to i32\l  store i32 %EAX, ptr %stktop_8, align 1\l  %EAX5 = call i32 (ptr, ...) @printf(ptr getelementptr inbounds ([112 x i8],\l... ptr @rodata_15, i32 0, i32 19), i32 %ESI, i64 %RDX, i64 %memload2)\l  %24 = ptrtoint ptr %stktop_8 to i64\l  %25 = add i64 %24, 4\l  %26 = inttoptr i64 %25 to ptr\l  %memload6 = load i32, ptr %26, align 1\l  %EAX13 = add i32 %memload6, 1\l  %27 = call \{ i32, i1 \} @llvm.uadd.with.overflow.i32(i32 %memload6, i32 1)\l  %CF7 = extractvalue \{ i32, i1 \} %27, 1\l  %28 = and i32 %EAX13, 255\l  %29 = call i32 @llvm.ctpop.i32(i32 %28)\l  %30 = and i32 %29, 1\l  %PF8 = icmp eq i32 %30, 0\l  %ZF9 = icmp eq i32 %EAX13, 0\l  %highbit10 = and i32 -2147483648, %EAX13\l  %SF11 = icmp ne i32 %highbit10, 0\l  %31 = call \{ i32, i1 \} @llvm.sadd.with.overflow.i32(i32 %memload6, i32 1)\l  %OF12 = extractvalue \{ i32, i1 \} %31, 1\l  %32 = ptrtoint ptr %stktop_8 to i64\l  %33 = add i64 %32, 4\l  %34 = inttoptr i64 %33 to ptr\l  store i32 %EAX13, ptr %34, align 1\l  br label %bb.1\l}"];
	Node0x5565e7bb1e80 -> Node0x5565e7bb0ea0;
	Node0x5565e7bb1e10 [shape=record,color="#3d50c3ff", style=filled, fillcolor="#b9d0f970",label="{bb.3:                                             \l  ret i64 %RAX\l}"];
}
