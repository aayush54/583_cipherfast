digraph "CFG for 'mix_comp' function" {
	label="CFG for 'mix_comp' function";

	Node0x5565e7ba4450 [shape=record,color="#3d50c3ff", style=filled, fillcolor="#b9d0f970",label="{entry:\l  %stktop_4 = alloca i8, i32 40, align 1\l  %tos = ptrtoint ptr %stktop_4 to i64\l  %0 = add i64 %tos, 12\l  %RBP_N.28 = inttoptr i64 %0 to ptr\l  %1 = add i64 %tos, 16\l  %RBP_N.24 = inttoptr i64 %1 to ptr\l  %2 = add i64 %tos, 24\l  %RBP_N.16 = inttoptr i64 %2 to ptr\l  %3 = add i64 %tos, 32\l  %RBP_N.8 = inttoptr i64 %3 to ptr\l  %4 = add i64 %tos, 0\l  %RSP_P.0 = inttoptr i64 %4 to ptr\l  store i64 3735928559, ptr %RSP_P.0, align 8\l  %RBP = ptrtoint ptr %RSP_P.0 to i64\l  store i64 %arg1, ptr %RBP_N.8, align 1\l  store i64 %arg2, ptr %RBP_N.16, align 1\l  store i64 %arg3, ptr %RBP_N.24, align 1\l  store i32 %arg4, ptr %RBP_N.28, align 1\l  store i32 0, ptr %stktop_4, align 1\l  br label %bb.1\l}"];
	Node0x5565e7ba4450 -> Node0x5565e7ba5230;
	Node0x5565e7ba5230 [shape=record,color="#b70d28ff", style=filled, fillcolor="#b70d2870",label="{bb.1:                                             \l  %memload = load i32, ptr %stktop_4, align 1\l  %5 = load i32, ptr %RBP_N.28, align 1\l  %6 = sub i32 %memload, %5\l  %7 = call \{ i32, i1 \} @llvm.usub.with.overflow.i32(i32 %memload, i32 %5)\l  %CF = extractvalue \{ i32, i1 \} %7, 1\l  %ZF = icmp eq i32 %6, 0\l  %highbit = and i32 -2147483648, %6\l  %SF = icmp ne i32 %highbit, 0\l  %8 = call \{ i32, i1 \} @llvm.ssub.with.overflow.i32(i32 %memload, i32 %5)\l  %OF = extractvalue \{ i32, i1 \} %8, 1\l  %9 = and i32 %6, 255\l  %10 = call i32 @llvm.ctpop.i32(i32 %9)\l  %11 = and i32 %10, 1\l  %PF = icmp eq i32 %11, 0\l  %CmpSFOF_JGE = icmp eq i1 %SF, %OF\l  br i1 %CmpSFOF_JGE, label %bb.3, label %bb.2\l|{<s0>T|<s1>F}}"];
	Node0x5565e7ba5230:s0 -> Node0x5565e7ba5df0;
	Node0x5565e7ba5230:s1 -> Node0x5565e7ba5e60;
	Node0x5565e7ba5e60 [shape=record,color="#b70d28ff", style=filled, fillcolor="#bb1b2c70",label="{bb.2:                                             \l  %memload1 = load i64, ptr %RBP_N.16, align 1\l  %memload2 = load i64, ptr %stktop_4, align 1\l  %12 = trunc i64 %memload2 to i32\l  %RCX = sext i32 %12 to i64\l  %memref-basereg = add i64 %memload1, %RCX\l  %13 = inttoptr i64 %memref-basereg to ptr\l  %memload3 = load i32, ptr %13, align 1\l  %14 = trunc i32 %memload3 to i8\l  %EDX = sext i8 %14 to i32\l  %memload4 = load i64, ptr %RBP_N.24, align 1\l  %memload5 = load i64, ptr %stktop_4, align 1\l  %15 = trunc i64 %memload5 to i32\l  %RCX6 = sext i32 %15 to i64\l  %memref-basereg7 = add i64 %memload4, %RCX6\l  %16 = inttoptr i64 %memref-basereg7 to ptr\l  %memload8 = load i32, ptr %16, align 1\l  %17 = trunc i32 %memload8 to i8\l  %ESI = sext i8 %17 to i32\l  %EDX9 = mul nsw i32 %EDX, %ESI\l  %memload10 = load i64, ptr %RBP_N.8, align 1\l  %memload11 = load i64, ptr %stktop_4, align 1\l  %18 = trunc i64 %memload11 to i32\l  %RCX12 = sext i32 %18 to i64\l  %memref-basereg13 = add i64 %memload10, %RCX12\l  %19 = trunc i32 %EDX9 to i8\l  %20 = inttoptr i64 %memref-basereg13 to ptr\l  store i8 %19, ptr %20, align 1\l  %memload14 = load i32, ptr %stktop_4, align 1\l  %EAX = add i32 %memload14, 1\l  %21 = call \{ i32, i1 \} @llvm.uadd.with.overflow.i32(i32 %memload14, i32 1)\l  %CF15 = extractvalue \{ i32, i1 \} %21, 1\l  %22 = and i32 %EAX, 255\l  %23 = call i32 @llvm.ctpop.i32(i32 %22)\l  %24 = and i32 %23, 1\l  %PF16 = icmp eq i32 %24, 0\l  %ZF17 = icmp eq i32 %EAX, 0\l  %highbit18 = and i32 -2147483648, %EAX\l  %SF19 = icmp ne i32 %highbit18, 0\l  %25 = call \{ i32, i1 \} @llvm.sadd.with.overflow.i32(i32 %memload14, i32 1)\l  %OF20 = extractvalue \{ i32, i1 \} %25, 1\l  store i32 %EAX, ptr %stktop_4, align 1\l  br label %bb.1\l}"];
	Node0x5565e7ba5e60 -> Node0x5565e7ba5230;
	Node0x5565e7ba5df0 [shape=record,color="#3d50c3ff", style=filled, fillcolor="#b9d0f970",label="{bb.3:                                             \l  ret i32 %memload\l}"];
}
